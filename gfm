#!/bin/bash

# Git Fix Manager (gfm) - Interface simplifiée et intelligente
# Version 1.0 - Outil professionnel de gestion des corrections
# https://github.com/RenZan/gitfixmanager

set -e

# Configuration
VERSION="1.2.0"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
DETECTOR="$SCRIPT_DIR/scripts/missing-fix-detector.sh"

# Support pour installation globale - mais vérifier d'abord que le fichier local existe
if [[ ! -f "$DETECTOR" ]]; then
    # Si le fichier local n'existe pas, chercher une installation globale
    if [[ -n "${GFM_INSTALL_DIR:-}" ]]; then
        DETECTOR="$GFM_INSTALL_DIR/scripts/missing-fix-detector.sh"
    elif [[ -f "/home/renzan/.local/share/gfm/scripts/missing-fix-detector.sh" ]]; then
        DETECTOR="/home/renzan/.local/share/gfm/scripts/missing-fix-detector.sh"
    elif [[ -f "/home/renzan/.local/share/gfm/missing-fix-detector.sh" ]]; then
        DETECTOR="/home/renzan/.local/share/gfm/missing-fix-detector.sh"
    fi
fi

# Fonction de vérification du détecteur (appelée seulement si nécessaire)
check_detector() {
    if [[ ! -f "$DETECTOR" ]]; then
        echo -e "${ERROR_ICON:-❌} ${RED:-}Détecteur non trouvé: $DETECTOR${NC:-}"
        echo -e "${INFO_ICON:-💡} ${CYAN:-}SCRIPT_DIR résolu: $SCRIPT_DIR${NC:-}"
        exit 1
    fi
}

# Couleurs ANSI
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m'

# Icônes pour améliorer l'UX
BUG_ICON="🐛"
FIX_ICON="🔧"
CHECK_ICON="✅"
WARNING_ICON="⚠️"
ERROR_ICON="❌"
INFO_ICON="💡"
ROCKET_ICON="🚀"

# Fonction pour obtenir le nom de la branche courante
get_current_branch_name() {
    local branch=$(git branch --show-current 2>/dev/null)
    if [ -n "$branch" ]; then
        echo "$branch"
    else
        # Fallback pour les cas où on est en état detached HEAD
        local describe=$(git describe --all --exact-match HEAD 2>/dev/null | sed 's|^heads/||')
        if [ -n "$describe" ]; then
            echo "$describe"
        else
            echo "HEAD"
        fi
    fi
}
LIST_ICON="📝"
STATUS_ICON="📊"

# Vérifications de base (git installé)
check_basic_prerequisites() {
    if ! command -v git &> /dev/null; then
        echo -e "${ERROR_ICON} ${RED}Git n'est pas installé${NC}"
        exit 1
    fi
}

# Vérifications pour les commandes nécessitant un repo git
check_git_repo() {
    if ! git rev-parse --git-dir &> /dev/null; then
        echo -e "${ERROR_ICON} ${RED}Vous devez être dans un repository Git${NC}"
        exit 1
    fi
}

# Vérifications du script detector
check_detector() {
    if [[ ! -f "$DETECTOR" ]]; then
        echo -e "${ERROR_ICON} ${RED}Script de détection non trouvé : $DETECTOR${NC}"
        echo -e "${INFO_ICON} ${CYAN}Vérifiez votre installation avec install-smart.sh${NC}"
        exit 1
    fi
}

# Vérification et mise à jour de gfm
check_for_updates() {
    echo -e "${INFO_ICON} ${CYAN}Vérification des mises à jour...${NC}"
    
    # Obtenir la dernière version directement depuis le fichier principal
    if command -v curl &> /dev/null; then
        latest_version=$(curl -s --connect-timeout 10 https://raw.githubusercontent.com/RenZan/gitfixmanager/main/gfm 2>/dev/null | grep '^VERSION=' | cut -d'"' -f2 | head -1 || echo "")
    elif command -v wget &> /dev/null; then
        latest_version=$(wget --timeout=10 -qO- https://raw.githubusercontent.com/RenZan/gitfixmanager/main/gfm 2>/dev/null | grep '^VERSION=' | cut -d'"' -f2 | head -1 || echo "")
    else
        echo -e "${ERROR_ICON} ${RED}curl ou wget requis pour vérifier les mises à jour${NC}"
        exit 1
    fi
    
    if [[ -z "$latest_version" ]]; then
        echo -e "${ERROR_ICON} ${RED}Impossible de vérifier les mises à jour${NC}"
        echo -e "${INFO_ICON} ${CYAN}Vérifiez votre connexion Internet et réessayez${NC}"
        exit 1
    fi
    
    # Comparer les versions
    if [[ "$latest_version" == "$VERSION" ]]; then
        echo -e "${SUCCESS_ICON} ${GREEN}Git Fix Manager est à jour (version $VERSION)${NC}"
    else
        echo -e "${WARNING_ICON} ${YELLOW}Nouvelle version disponible : $latest_version (actuelle: $VERSION)${NC}"
        echo ""
        read -p "Voulez-vous mettre à jour ? (y/N): " choice
        case $choice in
            [Yy]|[Oo])
                echo -e "${INFO_ICON} ${CYAN}Téléchargement et installation de la mise à jour...${NC}"
                if command -v curl &> /dev/null; then
                    curl -fsSL https://raw.githubusercontent.com/RenZan/gitfixmanager/main/install.sh | bash
                else
                    wget -qO- https://raw.githubusercontent.com/RenZan/gitfixmanager/main/install.sh | bash
                fi
                echo -e "${SUCCESS_ICON} ${GREEN}Mise à jour terminée !${NC}"
                ;;
            *)
                echo -e "${INFO_ICON} ${CYAN}Mise à jour annulée${NC}"
                ;;
        esac
    fi
}

# Génération d'ID de bug automatique et intelligent
generate_bug_id() {
    local description="$1"
    local prefix="BUG"
    local date_part=$(date +%Y%m%d)
    
    # Générer un hash court basé sur la description
    local desc_hash
    if command -v md5sum &> /dev/null; then
        desc_hash=$(echo "$description" | md5sum | cut -c1-4 | tr '[:lower:]' '[:upper:]')
    elif command -v openssl &> /dev/null; then
        desc_hash=$(echo "$description" | openssl md5 | tail -c 5 | tr '[:lower:]' '[:upper:]')
    else
        # Fallback: hash simple basé sur la longueur et premier caractère
        desc_hash=$(printf "%04X" $((${#description} * 17 + $(printf "%d" "'${description:0:1}"))))
    fi
    
    echo "${prefix}-${date_part}-${desc_hash}"
}

# Auto-détection du contexte
detect_context() {
    local input="$1"
    
    # Si l'input ressemble à un BUG-ID
    if [[ "$input" =~ ^BUG-[0-9]{8}-[A-F0-9]{4}$ ]]; then
        echo "bug-id"
    # Si l'input ressemble à un hash de commit
    elif [[ "$input" =~ ^[a-f0-9]{7,40}$ ]]; then
        echo "commit-hash"
    # Si l'input ressemble à une description de bug
    elif [[ ${#input} -gt 10 && "$input" =~ [[:space:]] ]]; then
        echo "bug-description"
    # Si c'est un nom de branche/tag
    elif git rev-parse --verify "$input" &>/dev/null; then
        echo "branch-or-tag"
    else
        echo "unknown"
    fi
}

# Trouver automatiquement le commit d'un bug
find_bug_commit() {
    local bug_id="$1"
    local result=""
    local one_year_ago=$(date -d "1 year ago" +%Y-%m-%d 2>/dev/null || date -v-1y +%Y-%m-%d 2>/dev/null || echo "2023-01-01")
    
    # Éviter le pipe pour éviter le sous-shell
    local notes_list=$(git notes --ref=refs/notes/bugs list 2>/dev/null)
    
    while read -r note_hash commit_hash; do
        if [[ -n "$commit_hash" ]]; then
            # Vérifier si le commit est récent (dernière année)
            if git rev-list --since="$one_year_ago" --pretty=format: --abbrev-commit "$commit_hash" >/dev/null 2>&1; then
                local bug_info=$(git notes --ref=refs/notes/bugs show "$commit_hash" 2>/dev/null || echo "")
                if [[ "$bug_info" == *"$bug_id"* ]]; then
                    echo "$commit_hash"
                    return 0
                fi
            fi
        fi
    done <<< "$notes_list"
    
    return 1
}

# Mode interactif pour les débutants
interactive_mode() {
    echo -e "${ROCKET_ICON} ${BOLD}${CYAN}Git Fix Manager - Mode Interactif${NC}"
    echo -e "${CYAN}====================================${NC}"
    echo
    echo -e "${INFO_ICON} Ce mode vous guide étape par étape"
    echo
    echo "Que voulez-vous faire ?"
    echo "  1) ${BUG_ICON} Marquer un bug"
    echo "  2) ${FIX_ICON} Marquer une correction"
    echo "  3) ${CHECK_ICON} Vérifier les corrections"
    echo "  4) ${LIST_ICON} Lister bugs/corrections"
    echo "  5) ${STATUS_ICON} Voir le statut"
    echo "  0) Quitter"
    echo
    read -p "Votre choix (1-5, 0): " choice
    
    case $choice in
        1)
            echo
            echo -e "${BUG_ICON} ${BOLD}Marquer un bug${NC}"
            echo "Décrivez le bug en quelques mots :"
            read -p "> " description
            if [[ -n "$description" ]]; then
                echo
                echo "Sur quel commit marquer ce bug ?"
                echo "  1) Commit actuel ($(get_current_branch_name))"
                echo "  2) Autre commit (hash, branche, tag)"
                read -p "Choix (1-2, défaut=1): " commit_choice
                
                case "${commit_choice:-1}" in
                    1)
                        mark_bug_interactive "$description"
                        ;;
                    2)
                        echo "Hash/branche/tag du commit :"
                        read -p "> " target_commit
                        if [[ -n "$target_commit" ]]; then
                            mark_bug_interactive "$description" "$target_commit"
                        else
                            echo -e "${ERROR_ICON} Commit requis"
                        fi
                        ;;
                    *)
                        echo -e "${ERROR_ICON} Choix invalide"
                        ;;
                esac
            else
                echo -e "${ERROR_ICON} Description requise"
            fi
            ;;
        2)
            echo
            echo -e "${FIX_ICON} ${BOLD}Marquer une correction${NC}"
            mark_fix_interactive
            ;;
        3)
            echo
            echo -e "${CHECK_ICON} ${BOLD}Vérifier les corrections${NC}"
            echo "Branche/tag à vérifier (laissez vide pour la branche actuelle) :"
            read -p "> " target
            check_fixes_interactive "${target:-HEAD}"
            ;;
        4)
            echo
            list_interactive
            ;;
        5)
            echo
            show_status_interactive
            ;;
        0)
            echo "Au revoir !"
            ;;
        *)
            echo -e "${ERROR_ICON} Choix invalide"
            ;;
    esac
}

# Marquer un bug de manière interactive
mark_bug_interactive() {
    local description="$1"
    local specified_commit="$2"
    local bug_id=$(generate_bug_id "$description")
    
    # Gestion intelligente du commit
    local commit
    if [[ -n "$specified_commit" ]]; then
        # Vérifier que le commit existe
        if ! git rev-parse --verify "$specified_commit" >/dev/null 2>&1; then
            echo -e "${ERROR_ICON} ${RED}Commit '$specified_commit' non trouvé${NC}"
            return 1
        fi
        commit=$(git rev-parse "$specified_commit")
        echo -e "${INFO_ICON} ${CYAN}Marquage sur commit spécifié${NC}"
    else
        commit=$(git rev-parse HEAD)
        echo -e "${INFO_ICON} ${CYAN}Marquage sur commit actuel ($(get_current_branch_name))${NC}"
    fi
    
    echo
    echo -e "${INFO_ICON} ID généré automatiquement : ${BOLD}$bug_id${NC}"
    echo -e "${INFO_ICON} Commit ciblé : ${BOLD}$(git rev-parse --short $commit)${NC}"
    if [[ -n "$specified_commit" ]]; then
        echo -e "${INFO_ICON} Message du commit : ${BOLD}$(git log --format='%s' -1 $commit)${NC}"
    fi
    echo -e "${INFO_ICON} Description : ${BOLD}$description${NC}"
    echo
    read -p "Confirmer ? (Y/n): " confirm
    
    if [[ "$confirm" =~ ^[Nn]$ ]]; then
        echo "Opération annulée"
        return 1
    fi
    
    echo -e "${BUG_ICON} Marquage du bug..."
    if "$DETECTOR" mark-bug "$commit" "$bug_id" "$description"; then
        echo -e "${CHECK_ICON} ${GREEN}Bug $bug_id marqué avec succès${NC}"
        echo -e "${INFO_ICON} ${CYAN}Utilisez 'gfm fix $bug_id' quand vous l'aurez corrigé${NC}"
    else
        echo -e "${ERROR_ICON} ${RED}Échec du marquage${NC}"
        return 1
    fi
}

# Fonction de sélection interactive simplifiée et robuste  
select_bug_interactive() {
    echo -e "${FIX_ICON} ${BOLD}${CYAN}Sélectionner le bug à corriger${NC}"
    echo -e "${CYAN}========================================${NC}"
    echo
    
    # Appel direct du détecteur et parsing simple - FILTRÉ par branche courante
    local output=$("$DETECTOR" list-bugs-current 2>/dev/null)
    
    if [[ -z "$output" ]]; then
        echo -e "${INFO_ICON} ${YELLOW}Aucun bug marqué trouvé${NC}"
        return 1
    fi
    
    # Parser simplement avec des tableaux
    local bug_ids=()
    local bug_commits=()
    local bug_descriptions=()
    
    while IFS= read -r line; do
        # Nettoyer les codes ANSI
        local clean_line=$(echo "$line" | sed 's/\x1b\[[0-9;]*m//g')
        
        if [[ "$clean_line" =~ ^Bug\ ID:\ (BUG-[0-9]{8}-[A-F0-9]{4}) ]]; then
            bug_ids+=("${BASH_REMATCH[1]}")
        elif [[ "$clean_line" =~ ^Commit:\ ([a-f0-9]{7}) ]]; then
            bug_commits+=("${BASH_REMATCH[1]}")
        elif [[ "$clean_line" =~ ^Description:\ (.+)$ ]]; then
            bug_descriptions+=("${BASH_REMATCH[1]}")
        fi
    done <<< "$output"
    
    if [[ ${#bug_ids[@]} -eq 0 ]]; then
        echo -e "${INFO_ICON} ${YELLOW}Aucun bug à corriger trouvé${NC}"
        return 1
    fi
    
    # Affichage de la liste
    for i in "${!bug_ids[@]}"; do
        local index=$((i + 1))
        echo -e "  ${BOLD}${YELLOW}[$index]${NC} ${BOLD}${bug_ids[$i]}${NC} ${CYAN}(${bug_commits[$i]})${NC}"
        echo -e "      ${bug_descriptions[$i]}"
        echo
    done
    
    # Sélection
    while true; do
        read -p "Choisissez un numéro (1-${#bug_ids[@]}) ou 'q' pour quitter: " choice
        
        if [[ "$choice" == "q" || "$choice" == "Q" ]]; then
            return 1
        fi
        
        if [[ "$choice" =~ ^[0-9]+$ ]] && [[ $choice -ge 1 ]] && [[ $choice -le ${#bug_ids[@]} ]]; then
            local selected_index=$((choice - 1))
            SELECTED_BUG_ID="${bug_ids[$selected_index]}"
            echo -e "${INFO_ICON} ${GREEN}Bug sélectionné: $SELECTED_BUG_ID${NC}"
            return 0
        else
            echo -e "${ERROR_ICON} ${RED}Choix invalide. Utilisez un numéro entre 1 et ${#bug_ids[@]}${NC}"
        fi
    done
}

# Sélectionner un commit de correction de manière interactive
select_fix_commit_interactive() {
    echo -e "${FIX_ICON} ${BOLD}Sélection du commit de correction${NC}"
    echo -e "${CYAN}========================================${NC}"
    echo
    
    # Afficher les derniers commits comme options
    echo -e "${INFO_ICON} ${CYAN}Commits récents disponibles :${NC}"
    echo
    
    # Récupérer les 10 derniers commits avec leurs informations
    local commits=($(git log --oneline -10 --format="%H"))
    local commit_shorts=($(git log --oneline -10 --format="%h"))
    
    # Affichage de la liste avec récupération individuelle des sujets
    for i in "${!commits[@]}"; do
        local index=$((i + 1))
        local commit_subject=$(git log -1 --format="%s" "${commits[$i]}")
        echo -e "  ${BOLD}${YELLOW}[$index]${NC} ${BOLD}${commit_shorts[$i]}${NC} ${commit_subject}"
    done
    
    echo
    echo -e "  ${BOLD}${YELLOW}[H]${NC} ${BOLD}$(get_current_branch_name)${NC} (commit actuel)"
    echo -e "  ${BOLD}${YELLOW}[C]${NC} Saisir un commit spécifique"
    echo
    
    # Sélection
    while true; do
        read -p "Choisissez une option (1-${#commits[@]}, H, C) ou 'q' pour quitter: " choice
        
        if [[ "$choice" == "q" || "$choice" == "Q" ]]; then
            return 1
        fi
        
        if [[ "$choice" == "h" || "$choice" == "H" ]]; then
            SELECTED_FIX_COMMIT=$(git rev-parse HEAD)
            echo -e "${INFO_ICON} ${GREEN}Commit sélectionné: $(git rev-parse --short HEAD) ($(get_current_branch_name))${NC}"
            return 0
        fi
        
        if [[ "$choice" == "c" || "$choice" == "C" ]]; then
            echo
            read -p "Entrez le hash du commit (court ou complet): " custom_commit
            if git rev-parse --verify "$custom_commit" >/dev/null 2>&1; then
                SELECTED_FIX_COMMIT=$(git rev-parse "$custom_commit")
                echo -e "${INFO_ICON} ${GREEN}Commit sélectionné: $(git rev-parse --short $custom_commit)${NC}"
                return 0
            else
                echo -e "${ERROR_ICON} ${RED}Commit invalide: $custom_commit${NC}"
                continue
            fi
        fi
        
        if [[ "$choice" =~ ^[0-9]+$ ]] && [[ $choice -ge 1 ]] && [[ $choice -le ${#commits[@]} ]]; then
            local selected_index=$((choice - 1))
            SELECTED_FIX_COMMIT="${commits[$selected_index]}"
            echo -e "${INFO_ICON} ${GREEN}Commit sélectionné: ${commit_shorts[$selected_index]}${NC}"
            return 0
        else
            echo -e "${ERROR_ICON} ${RED}Choix invalide. Utilisez un numéro entre 1 et ${#commits[@]}, H, C ou 'q'${NC}"
        fi
    done
}

# Marquer une correction de manière interactive
mark_fix_interactive() {
    local bug_id="$1"
    local fix_commit=""
    
    # Si aucun bug_id fourni, proposer la sélection interactive
    if [[ -z "$bug_id" ]]; then
        echo -e "${FIX_ICON} ${BOLD}Sélection interactive du bug à corriger${NC}"
        echo
        
        # Appel direct de la fonction avec gestion du retour
        if select_bug_interactive; then
            # La fonction a réussi, mais on doit récupérer le bug_id autrement
            # Pour l'instant, on utilise une variable globale
            bug_id="$SELECTED_BUG_ID"
        else
            echo
            echo -e "${INFO_ICON} ${YELLOW}Sélection annulée${NC}"
            return 1
        fi
        
        if [[ -z "$bug_id" ]]; then
            echo
            echo -e "${INFO_ICON} ${YELLOW}Aucun bug sélectionné${NC}"
            return 1
        fi
    fi
    
    # Maintenant sélectionner le commit de correction
    echo
    if select_fix_commit_interactive; then
        fix_commit="$SELECTED_FIX_COMMIT"
    else
        echo
        echo -e "${INFO_ICON} ${YELLOW}Sélection du commit annulée${NC}"
        return 1
    fi
    
    # Trouver le commit du bug
    local bug_commit=$(find_bug_commit "$bug_id")
    
    if [[ -z "$bug_commit" ]]; then
        echo -e "${ERROR_ICON} ${RED}Bug $bug_id non trouvé${NC}"
        echo
        echo -e "${INFO_ICON} ${CYAN}Bugs disponibles à corriger :${NC}"
        "$DETECTOR" list-bugs
        echo
        echo -e "${INFO_ICON} ${CYAN}Utilisez 'gfm fix BUG-ID' avec un ID valide${NC}"
        return 1
    fi
    
    echo
    echo -e "${INFO_ICON} Bug ID : ${BOLD}$bug_id${NC}"
    echo -e "${INFO_ICON} Commit du bug : ${BOLD}$(git rev-parse --short $bug_commit)${NC}"
    echo -e "${INFO_ICON} Commit de correction : ${BOLD}$(git rev-parse --short $fix_commit)${NC}"
    echo
    read -p "Confirmer la correction ? (Y/n): " confirm
    
    if [[ "$confirm" =~ ^[Nn]$ ]]; then
        echo "Opération annulée"
        return 1
    fi
    
    echo -e "${FIX_ICON} Marquage de la correction..."
    if "$DETECTOR" mark-fix "$fix_commit" "$bug_id" "$bug_commit"; then
        echo -e "${CHECK_ICON} ${GREEN}Correction $bug_id marquée avec succès${NC}"
    else
        echo -e "${ERROR_ICON} ${RED}Échec du marquage de la correction${NC}"
        return 1
    fi
}

# Vérification interactive
check_fixes_interactive() {
    local target="$1"
    
    echo -e "${CHECK_ICON} Vérification de $target..."
    echo
    
    if "$DETECTOR" check "$target"; then
        echo
        echo -e "${CHECK_ICON} ${GREEN}Toutes les corrections sont présentes !${NC}"
    else
        echo
        echo -e "${WARNING_ICON} ${YELLOW}Des corrections manquent. Voir détails ci-dessus.${NC}"
    fi
}

# Listing interactif
list_interactive() {
    echo -e "${LIST_ICON} ${BOLD}Bugs et corrections${NC}"
    echo
    echo "Que voulez-vous lister ?"
    echo "  1) Tous les bugs"
    echo "  2) Toutes les corrections"
    echo "  3) Tout"
    echo
    read -p "Votre choix (1-3): " choice
    
    case $choice in
        1)
            echo
            echo -e "${BUG_ICON} ${BOLD}Liste des bugs :${NC}"
            "$DETECTOR" list-bugs
            ;;
        2)
            echo
            echo -e "${FIX_ICON} ${BOLD}Liste des corrections :${NC}"
            "$DETECTOR" list-fixes
            ;;
        3)
            echo
            echo -e "${BUG_ICON} ${BOLD}Liste des bugs :${NC}"
            "$DETECTOR" list-bugs
            echo
            echo -e "${FIX_ICON} ${BOLD}Liste des corrections :${NC}"
            "$DETECTOR" list-fixes
            ;;
        *)
            echo -e "${ERROR_ICON} Choix invalide"
            ;;
    esac
}

# Statut interactif
show_status_interactive() {
    echo -e "${STATUS_ICON} ${BOLD}Statut du repository${NC}"
    echo
    local current_branch=$(git branch --show-current)
    local current_commit=$(git rev-parse --short HEAD)
    
    echo -e "${INFO_ICON} Branche actuelle : ${BOLD}$current_branch${NC}"
    echo -e "${INFO_ICON} Commit actuel : ${BOLD}$current_commit${NC}"
    echo
    
    "$DETECTOR" check HEAD
}

# Aide contextuelle intelligente
show_help() {
    local command="$1"
    
    case "$command" in
        "bug"|"b")
            echo -e "${BUG_ICON} ${BOLD}Aide : Marquer un bug${NC}"
            echo
            echo "Usage :"
            echo "  gfm bug \"description du bug\"          # Sur commit actuel"
            echo "  gfm bug \"description\" <commit>        # Sur commit spécifique"
            echo "  gfm b \"description\"                   # raccourci"
            echo
            echo "Exemples :"
            echo "  gfm bug \"Memory leak in parser\"        # Marque sur branche courante"
            echo "  gfm bug \"Bug in auth\" abc1234         # Marque sur commit abc1234"
            echo "  gfm bug \"Error handling\" main~3       # Marque sur 3 commits avant main"
            echo "  gfm bug \"Performance issue\" v1.0.0    # Marque sur tag v1.0.0"
            echo
            echo "Le bug sera marqué avec un ID auto-généré."
            echo "Le commit peut être spécifié par hash, branche, tag, ou référence relative."
            ;;
        "fix"|"f")
            echo -e "${FIX_ICON} ${BOLD}Aide : Marquer une correction${NC}"
            echo
            echo "Usage :"
            echo "  gfm fix BUG-ID"
            echo "  gfm f BUG-ID       # raccourci"
            echo
            echo "Exemples :"
            echo "  gfm fix BUG-20250918-A1B2"
            echo
            echo "La correction sera marquée sur le commit actuel."
            echo "Le commit du bug sera trouvé automatiquement."
            ;;
        "check"|"c")
            echo -e "${CHECK_ICON} ${BOLD}Aide : Vérifier les corrections${NC}"
            echo
            echo "Usage :"
            echo "  gfm check [branche/tag]"
            echo "  gfm c [branche/tag]    # raccourci"
            echo
            echo "Exemples :"
            echo "  gfm check              # branche actuelle"
            echo "  gfm check release/v1.0"
            echo "  gfm check v1.0.0"
            echo
            echo "Vérifie que tous les bugs présents ont leurs corrections."
            ;;
        "list"|"l")
            echo -e "${LIST_ICON} ${BOLD}Aide : Lister bugs/corrections${NC}"
            echo
            echo "Usage :"
            echo "  gfm list [bugs|fixes]"
            echo "  gfm l [bugs|fixes]     # raccourci"
            echo
            echo "Exemples :"
            echo "  gfm list               # tout"
            echo "  gfm list bugs         # seulement les bugs"
            echo "  gfm list fixes        # seulement les corrections"
            ;;
        *)
            echo -e "${ROCKET_ICON} ${BOLD}${CYAN}Git Fix Manager v$VERSION${NC}"
            echo -e "${CYAN}Interface simplifiée pour la gestion des bugs et corrections${NC}"
            echo
            echo -e "${BOLD}Commandes principales :${NC}"
            echo -e "  ${BUG_ICON} gfm bug \"description\"      Marquer un bug"
            echo -e "  ${FIX_ICON} gfm fix BUG-ID             Marquer une correction"
            echo -e "  ${CHECK_ICON} gfm check [branche/tag]    Vérifier les corrections"
            echo -e "  ${LIST_ICON} gfm list [bugs|fixes]      Lister bugs/corrections"
            echo -e "  ${STATUS_ICON} gfm status                Statut du repository"
            echo
            echo -e "${BOLD}Raccourcis :${NC}"
            echo "  gfm b = gfm bug"
            echo "  gfm f = gfm fix"
            echo "  gfm c = gfm check"
            echo "  gfm l = gfm list"
            echo "  gfm s = gfm status"
            echo
            echo -e "${BOLD}Autres commandes :${NC}"
            echo "  gfm interactive        Mode interactif guidé"
            echo "  gfm help [commande]    Aide spécifique"
            echo "  gfm --version          Version"
            echo "  gfm update             Vérifier et installer les mises à jour"
            echo
            echo -e "${BOLD}Exemples rapides :${NC}"
            echo -e "  ${CYAN}gfm bug \"Memory leak detected\"${NC}"
            echo -e "  ${CYAN}gfm fix BUG-20250918-A1B2${NC}"
            echo -e "  ${CYAN}gfm check release/v1.0${NC}"
            echo
            echo -e "${INFO_ICON} ${CYAN}Utilisez 'gfm interactive' pour un mode guidé${NC}"
            echo -e "${INFO_ICON} ${CYAN}Documentation complète : https://github.com/RenZan/gitfixmanager${NC}"
            ;;
    esac
}

# Auto-détection intelligente d'arguments
smart_parse() {
    local input="$1"
    local context=$(detect_context "$input")
    
    case $context in
        "bug-description")
            echo -e "${INFO_ICON} ${CYAN}Détection automatique : description de bug${NC}"
            mark_bug_interactive "$input"
            ;;
        "bug-id")
            echo -e "${INFO_ICON} ${CYAN}Détection automatique : ID de bug${NC}"
            echo "Que voulez-vous faire avec ce bug ?"
            echo "  1) Marquer comme corrigé"
            echo "  2) Voir les détails"
            read -p "Choix (1-2): " choice
            case $choice in
                1) mark_fix_interactive "$input" ;;
                2) 
                    echo "Recherche de $input..."
                    "$DETECTOR" list-bugs | grep -i "$input" || echo "Bug non trouvé"
                    ;;
            esac
            ;;
        "branch-or-tag")
            echo -e "${INFO_ICON} ${CYAN}Détection automatique : branche/tag${NC}"
            check_fixes_interactive "$input"
            ;;
        *)
            echo -e "${WARNING_ICON} ${YELLOW}Contexte non reconnu pour : $input${NC}"
            echo -e "${INFO_ICON} ${CYAN}Utilisez 'gfm help' pour voir les commandes disponibles${NC}"
            ;;
    esac
}

# Fonction principale
main() {
    local command="${1:-}"
    
    case "$command" in
        # Commandes qui n'ont PAS besoin du repo git
        "help"|"h")
            check_basic_prerequisites
            shift
            show_help "$1"
            exit 0
            ;;
        "--version"|"-v")
            check_basic_prerequisites
            echo "Git Fix Manager v$VERSION"
            exit 0
            ;;
        "update")
            check_basic_prerequisites
            check_for_updates
            exit 0
            ;;
        
        # Toutes les autres commandes nécessitent le repo git et le détecteur
        *)
            check_basic_prerequisites
            check_git_repo
            check_detector
            ;;
    esac
    
    # Nouveau case pour les commandes nécessitant le détecteur
    case "$command" in
        # Commandes principales
        "bug"|"b")
            shift
            if [[ $# -eq 0 ]]; then
                echo -e "${ERROR_ICON} ${RED}Description du bug requise${NC}"
                echo -e "${INFO_ICON} ${CYAN}Usage: gfm bug \"description\" [commit]${NC}"
                echo -e "${INFO_ICON} ${CYAN}Exemples:${NC}"
                echo -e "${INFO_ICON} ${CYAN}  gfm bug \"Memory leak\"           # Sur branche courante${NC}"
                echo -e "${INFO_ICON} ${CYAN}  gfm bug \"Bug xyz\" abc1234      # Sur commit abc1234${NC}"
                exit 1
            fi
            
            # Séparer description et commit
            local description=""
            local target_commit=""
            
            # Si on a plus d'un argument, vérifier si le dernier est un commit
            if [[ $# -gt 1 ]]; then
                local last_arg="${!#}"
                
                # Vérifier si le dernier argument est un commit valide
                if git rev-parse --verify "$last_arg" >/dev/null 2>&1; then
                    # Le dernier argument est un commit valide
                    target_commit="$last_arg"
                    # Tous les arguments sauf le dernier forment la description
                    local args=("$@")
                    unset 'args[-1]'
                    description="${args[*]}"
                else
                    # Le dernier argument n'est pas un commit, tout fait partie de la description
                    description="$*"
                fi
            else
                # Un seul argument = description
                description="$*"
            fi
            
            # Validation finale
            if [[ -z "$description" ]]; then
                echo -e "${ERROR_ICON} ${RED}Description vide${NC}"
                exit 1
            fi
            
            mark_bug_interactive "$description" "$target_commit"
            ;;
        "fix"|"f")
            shift
            if [[ $# -eq 0 ]]; then
                mark_fix_interactive
            else
                mark_fix_interactive "$1"
            fi
            ;;
        "check"|"c")
            shift
            local target="${1:-HEAD}"
            check_fixes_interactive "$target"
            ;;
        "list"|"l")
            shift
            case "${1:-}" in
                "bugs") 
                    echo -e "${BUG_ICON} ${BOLD}Liste des bugs :${NC}"
                    "$DETECTOR" list-bugs 
                    ;;
                "fixes") 
                    echo -e "${FIX_ICON} ${BOLD}Liste des corrections :${NC}"
                    "$DETECTOR" list-fixes 
                    ;;
                *) 
                    echo -e "${BUG_ICON} ${BOLD}Liste des bugs :${NC}"
                    "$DETECTOR" list-bugs
                    echo
                    echo -e "${FIX_ICON} ${BOLD}Liste des corrections :${NC}"
                    "$DETECTOR" list-fixes
                    ;;
            esac
            ;;
        "status"|"s")
            show_status_interactive
            ;;
        
        # Commandes spéciales
        "interactive"|"i")
            interactive_mode
            ;;
        
        # Mode sans arguments ou auto-détection
        "")
            interactive_mode
            ;;
        *)
            # Tentative d'auto-détection
            smart_parse "$command"
            ;;
    esac
}

# Point d'entrée
main "$@"